---
layout: article
title:  "brainiac"
date:   2013-10-20 13:46:21
categories: code
comments: true
share: true
excerpt: "Geographic Localization Using k-gon Clouds in Fixed Distance"
image:
  feature: brainiac-feature.jpg
  teaser: brainiac-teaser.jpg
  thumb: brainiac-thumb.jpg
  credit: Sylwia Bartyzel
  creditlink: https://unsplash.com/sylwiabartyzel
---


<h4 class="subtitle">Geographic Localization Using k-gon Clouds in Fixed Distance<a target="_blank" href="https://www.npmjs.org/package/brainiac"><i style="margin-left: 15px;" class="fa fa-external-link-square"></i></a>
<a target="_blank" href="http://www.github.com/jamesroseman/brainiac"><i class="fa fa-github-square"></i></a></h4>


{% include toc.html %}


<h2 id="introduction">introduction</h2>

<p>
    As part of my final assignment for <a target="_blank" href="http://www.cs.tufts.edu/comp/260">Comp260 &ndash; Advanced Algorithms</a> taught by Greg Aloupis and Andrew Winslow, I looked at a common problem in mobile development: how can you most efficiently computationally represent geographic locations for fixed distance proximity queries. If the question is "how many ATMs are within 5 miles" or "how many burrito bars are within 10 blocks" it can be efficiently answered using this computational structure (hereon referenced as <a target="_blank" href="http://www.github.com/jamesroseman/brainiac">brainiac</a>).
</p>
<table>
	<thead>
		<tr>
			<th style="text-align: center">Brainiac is based on an augmented binary search tree ( <code>augBST</code> ) which adheres to the following properties</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td style="text-align: center">Some node in the <code>augBST</code> stores an interval <code>(0,100)</code></td>
		</tr>
		<tr>
			<td style="text-align: center">The left child of some node of some interval contains the lesser half of that interval. <code>(0,50)</code></td>
		</tr>
		<tr>
			<td style="text-align: center">The right child of some node of some interval contains the greater half of that interval. <code>(50,100)</code></td>
		</tr>
		<tr>
			<td style="text-align: center">Whenever a child node is created, all eligble members of the parent node's data set are "waterfalled" to the child, such that a node with two children has an empty data set.</td>
		</tr>
		<tr>
			<td style="text-align: center">Any node with two children contains an empty data set.</td>
		</tr>
		<tr>
			<td style="text-align: center">Whenever an insertion is called, a new child is created unless the interval of the to-be-created child node is less than some fixed minimum interval.</td>
		</tr>
	</tbody>
</table>
<br />
<p>
	The brainiac structure is a <code>longBST</code> (an <code>augBST</code> over <a target="_blank" href="http://en.wikipedia.org/wiki/Longitude">longitude</a> intervals) such that its root contains an interval of <code>(-180,180)</code> (the bounds of longitude). Every node in the <code>longBST</code> with less than two children contains a <code>latBST</code> (an <code>augBST</code> over <a target="_blank" href="http://en.wikipedia.org/wiki/Latitude">latitude</a> intervals) such that its root contains an interval of <code>(-90,90)</code> (the bounds of latitude).
</p>
<p>
	Consider the following set of coordinates (randomly chosen Starbucks locations across the United States).
</p>

<center><code>34.020029,-118.286931</code></center>
<center><code>29.426468,-98.491233</code></center>
<center><code>37.62261,-122.37804</code></center>
<center><code>61.59938,-149.126804</code></center>
<center><code>39.653671,-104.959502</code></center>
<center><code>47.850015,-122.279457</code></center>
<center><code>52.114942,-106.632519</code></center>
<center><code>47.622767,-122.33668</code></center>
<center><code>41.643112,-88.001369</code></center>

<div style="margin-top: 25px; margin-bottom: 15px; width: 90%; height: 450px; margin-left: auto; margin-right: auto;" id="map-canvas" class="google-map"></div>
	Scroll to zoom, click to shift.
<p>
	Longitude is represented on a map by vertical lines. Looking to the map above with the coordinates plotted, bisect the map to partition such that as few markers are in the same partition as possible, in as few partitions as possible. If some minimum "stopping distance" (at which no more partitions are made) were to be considered, this process would be identical to that of brainiac, namely by its <code>longBST</code>.
</p>
<p class='notice-inverse'>
	Following is a graphical representation of the <code>longBST</code> of a brainiac structure containing the above coordinates. Mouseover an individual node to see its interval.
</p>
<div style="width: 90%; height: 350px; margin: auto; margin-top: 20px; border: 1px solid black;" id="LocalizationProject1Graph"></div>
	Scroll to zoom, click to shift.
<p>
	As stated, the brainiac structure naturally partitions with an attempt to group as many data points together as possible. This is why narrow closely grouped paths form as seen above.
</p>


<hr>


##structure

<p class="under-title">
	For some set of location coordinates (ATMs, burrito bars, etc.), suppose the coordinates are inserted into the brainiac structure. As the <code>longBST</code> partitions the globe into vertical stripes and some <code>latBST</code> partitions those stripes horizontally, the brainiac structure as a whole can be thought of as partitioning the globe into small "interval squares", where some node in some <code>latBST</code> contains all location coordinates in that "interval square".
</p>
<p>
	For every location coordinate <code>c</code> inserted into the brainiac structure, insert <code>k</code> additional coordinates, where <code>k</code> represents some k-gon (a polygon with k sides) about <code>c</code> with some fixed distance <code>d</code>. These k-gon border coordinates contain some data representation of <code>c</code>, the original location coordinate (ATM, burrito bar, etc.).
</p>
<center>
	<code>40.7974,-74.481536</code>
</center>
<p class="caption">
	Recall the above coordinate from the <a href="#introduction">introduction</a> section.
</p>
<p>
	Suppose the following assumptions of the above variables:

    <ul>
    	<li><code>k=8</code></li>
    	<li><code>d=5 mi.</code></li>
    	<li><code>c=(40.7974,-74.481536)</code></li>
    </ul>

    This can be represented on a map as follows.
</p>
<div style="margin-top: 25px; margin-bottom: 15px; width: 90%; height: 450px; margin-left: auto; margin-right: auto;" id="map-canvas-2" class="google-map"></div>
	Scroll to zoom, click to shift
<p>
	For every location coordinate inserted into the brainiac structure, <code>k</code> additional coordiantes are inserted to represent the borders of some k-gon about that original coordinate. Though this decreases the space efficiency, it comparatively increases the time efficiency (see the <a href="#analysis">analysis</a> section for more). In using k-gon clouds, one can either store <code>k</code> additional coordinates on every insertion, or query <code>k</code> additional times on every query. Supposing some type of mobile application where many users may be accessing some type of fixed generally unchanging data set (like ATMs in a country), the space cost is outweighed by the time benefit in average queries.
</p>
<p>
	For a visualization of the structure itself over some location data set, see the <a href="#introduction">introduction</a> section.
</p>


<hr>


##analysis

<p class="under-title">
	Consider what we may call a "simple" algorithm to solve this problem. Given a list of coordinates that refer to locations of ATMs and a query in the form of a coordinate of my realtime location, the simplest way to determine which ATMs are within 5 miles of the query coordinate to check the distance between every location coordinate and the query coordinate. Suppose this application is built to determine how many ATMs are within a 5 mile radius of some query coordinate (there are roughly 480,000 ATMs in the United States of America) and a problem forms in the question of efficiency.
</p>

<p>
	So how efficient is brainiac as compared to this described simple method? First consider the simple method's efficiency.
</p>

{% highlight text %}
Let q be the query coordinate

For every fixed coordinate c:
	Compare distance from c to q.
	If distance(c, q) < d, add c to return list.
Return return list.
{% endhighlight %}

<p>
	For every location coordinate we do some sort of computation. The computation can be considered constant, as the <a href="http://en.wikipedia.org/wiki/Haversine_formula">haversine formula</a>, which is used for <a href="http://en.wikipedia.org/wiki/Great-circle_distance">great circle distance</a>, is some constant unchanging formula. Therefore we end up with the following time analysis of the simple method:
</p>
<center><code>O(n) + O(1) + O(1)</code></center>
<p> 
	Therefore the simple method takes <code>O(n)</code> time, or on the order of linear time.
</p>
<p>
	To reasonably compare, let us look at the brainiac method in the same pseudocode time analysis approach:
</p>

{% highlight text %}
Let q be the query coordinate
Let longBST be the augBST of all longitude intervals
Let qLa be the node in the longBST, whose interval contains q
Let qLo be the node in qLa's latBST, whose interval contains q

Search longBST for qLa
Search qLa's latBST for qLo
For every fixed coordinate c in qLo:
	Compare distance c to q.
	If distance (c,q) < d, add c to return list.
Return return list.
{% endhighlight %}

<p>
	First search to find the correct longitude interval in the <code>longBST</code>. This search takes logarithmic time. Then search to find the correct latitude interval over our found longitude interval, which again takes logarithmic time. We are left with a smaller representation of our absolute data set, over which we iterate and do some constant computation (for the same reason as the simple method). Therefore we end up with the following time analysis of the brainiac method:
</p>

<center><code>O(logn) + O(logn) + O(n)</code></center>

<p>
	Therefore the brainiac method takes at worst <code>O(n)</code> time, or on the order of linear time. This is the same as the simple method, and while it is a valid time analysis, it is not as accurate as it could be. An amortized analysis is required.
</p>

<p>
	The <code>O(n)</code> is not quite right, it should really be some <code>O(m)</code>, where <code>m</code> represents the average density of the intervals in the entire brainiac structure. The smaller the <code>m</code>, the more efficient the algorithm becomes. Reducing the average density of these "interval squares" is to increase the number of "interval squares", or increase the number of <code>latBST</code>. Therefore, to decrease <code>m</code> is to increase how populated our longitude aBST is. The only way to do this is to reduce the minimum distance at which new child nodes are created. Therefore, to reduce <code>m</code> is to reduce the minimum stopping distance.
</p>
<p>
	We have now also found the worst and best case scenarios of brainiac. Therefore, the worst case for this algorithm is a sparsely populated longitude augmented binary search tree, which will naturally increase the average density of "interval squares". This will naturally occur when the data points are clumped in small pockets of density (imagine 50 ATMs on one street). The best case for this algorithm is a heavily populated longitude augmented binary search tree, which will naturally reduce the average density of "interval squares". This will naturally occur when location coordinates are sparsely distributed.
</p>
<p>
	In pragmatic use cases, the brainiac structure can query locations in sublinear time. The ideal <code>k</code> is 8 or 16, as any less impacts accuracy and any more introduces redundant data points (k-gon borders which are not spread throughout different "interval squares"). Suppose some fixed <code>d</code> of 5 miles on 1,000 queries.
</p>
<ul>
	<li>Red: Simple method</li>
	<li>Purple: <code>k=16</code></li>
	<li>Teal: <code>k=8</code></li>
	<li>Red: <code>k=4</code></li>
</ul>
<p>
	The x-axis represents locations, whereas the y-axis represents time in milliseconds.
</p>
<center>
	<img style="width: 500px;" src="/images/localization/graph_1.png" /><br /><br />
	<img style="width: 500px;" src="/images/localization/graph_2.png" /><br /><br />
	<img style="width: 500px;" src="/images/localization/graph_3.png" /><br /><br />
</center>
<p>
	The following charts contain the raw data on which the above graphs are based. Time is in milliseconds and, as stated, all structures were exposed to 1,000 randomly generated queries on the location/item coordinates.
</p>

<p>
	Please note that "item" and "location" are used interchangably in the charts and on this page, both refer to the static unchanging coordinates to which proximity is being tested against some query coordinate.
</p>
<center>
	<img style="width: 500px;" src="/images/localization/data_set_1.png" /><br /><br />
	<img style="width: 500px;" src="/images/localization/data_set_2.png" /><br /><br />
	<img style="width: 500px;" src="/images/localization/data_set_3.png" /><br /><br />
</center>


<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script src="https://maps.googleapis.com/maps/api/js?v=3.exp&sensor=false"></script>
<script src="/js/vendor/jquery-1.9.1.min.js"></script>
<script src="/js/vendor/sigma.min.js"></script>
<script src="/js/vendor/sigma.parsers.json.min.js"></script>
<script src="/js/brainiac-post.js"></script>